■생성 패턴
- 싱승톤 패턴
- 빌더 패턴
 1. 복잡객체 생성
 2. 
- 팩토리 패턴: 구현부와 생성부가 느슨하게 연결됨. 단일책임원칙. 
 *정적 팩토리
  1. 하나의 정적 메서드가 서브 클래스 객체 반환
 *단순 팩토리
 *팩토리 메소드 패턴
 *추상 팩토리
  1. 상호의존적 객체군 생성 시 사용. 
 1 기존 클라이언트를 훼손하지 않고 새로운 기능을 구현하기 위해.
 2 클래스가 약간씩만 다른 경우.
 3. 업캐스팅, 다운캐스팅이 자주 발생할 때.
- 프로토타입
 1. 복잡한 객체를 생성하는 비용이 클 때 사용.
 2. 원형 객체를 미리 생성, 이를 복제해 새 객체 생성하는 방식.
- 오브젝트 풀

■구조 패턴
- 어댑터 
 * 라이브러리/시스템 기능을 사용하려 하나, 그 인터페이스가 혀냊 시스템과 맞지 않을 때
 * 현재 시스템과 사용하고자 하는 시스템간의 호환되지 않는 인터페이스를 중간에 어뎁터 인터페이스를 사용하여 연결해주는 디자인
 * 
 1. Object Adapter 패턴 : 어뎁터 클래스가 Adaptee(어뎁티) 객체를 자신의 멤버로 내포하는 Composition 방식
 2. Class Adapter 패턴 : 어뎁티를 상속함.
- 브릿지
 * 실제 로직을 담은 구현 클래스를 직접 호출하는 게 아니라, 이 구현체로부터 추상층 츨래스를 분리하여 클라이언트는 이 추상층 클래스를 거쳐 구현체 클래스를 사용하도록 하는 방식.
 * 클라이언트가 추상층 클래스를 호출할 때는 어떤 
- 복합체 패턴
 * 개별 객체나 객체들의 그룹을 클라이언트 입장에서 동일하게 취급하고 사용할 수 있게 하는 구조를 갖는 패턴.
 * ex) 디렉토리 내에는 파일과 파일의 묶음(디렉토리)를 포함할 수 있음.
- 데코레이터 패턴
 * 기존 객체의 구조를 보존한 채 부가적 기능을 동적으로 추가하기 위해 사용됨.
 * 보통 클래스에 새로운 기능을 추가하려면 파생 클레스를 만듦.
 * 데코레이터 패턴은 원본 클레스를 상속하고 내부 멤버로 가진 Decorator로 임시로 기능을 추가할 수 있음.
- 오브젝트풀 패턴
- Facade 패턴
 * 복잡한 서브 시스템을 펴닣 사용하기 위해
- 프랑스어로 건축물의 정면. 건축물의 정면 같이 꼭 필요한 인터페이스만 노출, 내부적으로는 서브시스템을 호출하여 기능 구현.
- 기존에 존재하는 서브시스템을 활용해 이를 묶어 새로운 기능을 구현하는 것. 그리고 외부에서 사용시에는 그 서브 시스템을 노출시키지 않는 것.
- Proxy 패턴
 * 클라이언트와 실제 사용하는 객체 사이에 대리자(Proxy)를 두고 실제 객체 대신 프록시를 호출하는 방식.
 * 프록시는 실제 객체와 동일한 인터페이스를 가짐.
 * 실제 객체에 직접 접근하는 대신 인터페이스를 재정의한 프록시를 통해 호출함으로서 안정성을 높이는 패턴.
- Flyweight 패턴
 * 객체들간의 공통된 데이터를 공유하여 RAM에 더 많은 객체를 포함할 수 있도록 하는 패턴.
 * 비슷한 데이터는 하나의 객체만 만들고 다른 객체가 이를 참조하는 형태.
 * ≡유니티의 프리팹

■행위 패턴
- Iterator 패턴(반복자)
 * 컬렉션 자료구조를 순차적으로 엑세스하기 위해 Iterator를 구현하는 것.
 * 서로 다른 자료구조에 대해 동일한 엑세스가 필요할 때 사용됨.
- Visiter 패턴
 * 
- Observer 패턴
 * 한 객체가 변화하면, 그 객체에 의존하는 모든 객체들에게 변화를 통지하는 패턴.
 * Observer 패턴은 Observer 클래스와 Subject 클래스로 구성됨. Subject에서 변화 감지시 Observer가 이를 감지함.
 * 이벤트의 불안정성을 대체하기 위함.
 * 서브젝트의 구독은 옵저버에서 처리함.
- Strategy 패턴
 * 상속을 통해 상속받은 클래스의 함수를 부르되 다른 기능을 수행하는 것.
- Chain of Responsibility 패턴 (연쇄책임 패턴)
 * 한 문제에 대한 연쇄된 책임을 가진 클래스. 
 * 한 문제를 하나의 작업을 행하는 클래스를 순차적으로 거치며 해결하는 것.
- Command 패턴
 * 호출자가 명령의 수신자에게 직접 호출하는 것이 아닌, 중간의 Command 객체를 통해 명령을 전달.
 * 호출자는 수신자의 상태를 신경쓰지 않고 명령을 할 수 있음.
- Templete Method
 * (-)
- Mediator 패턴
 * 객체들이 서로간의 소통을 직접 하지 않고 중간 중재자를 통해 소통하는 패턴.
 * 중재자를 사용하면 다수의 객체들이 서로 직접 통신할 필요가 없어 상호 의존성과 유착성을 줄인다.
- State 패턴